<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# vos

```go
import "github.com/TrueHopolok/VladOS/modules/vos"
```

### VladOS Security

VladOS Security \(shortly VOS\) is a package used for all security related stuff inside VladOS the project. Below are all features this package provides.

### Key Chain

2 cryptografy keys used for JWT and thus for session encryption. Automatic keys switch after [EncryptionKeysSwitchingTime](<#EncryptionKeysSwitchingTime>) minutes ensures keys are hard to crack.

### Json Web Token functional

Fully working JWT with a nice functions to create and validate tokens. Used in combination with sessions and in [AuthMiddleware](<#AuthMiddleware>) functional.

For more details see [JWTheader](<#JWTheader>), \[NewJWT\], [ValidateJWT](<#ValidateJWT>).

### Password and Salt logic

Password is generated with [golang.org/x/crypto/argon2](<https://pkg.go.dev/golang.org/x/crypto/argon2/>) package. Salt is generated via [crypto/rand.Read](<https://pkg.go.dev/crypto/rand/#Read>) to ensure cryptografic salt.

For more details see [GenerateSalt](<#GenerateSalt>), [NewPSH](<#NewPSH>), [ValidatePSH](<#ValidatePSH>).

### Authentication

Implements [AuthMiddleware](<#AuthMiddleware>) to use in http server that handles whole authefication with cookie handlers. Saves result in the [net/http.Request.Context](<https://pkg.go.dev/net/http/#Request.Context>) for further use in the request handlers. Can be accessed via [GetSession](<#GetSession>) function.

## Index

- [Constants](<#constants>)
- [func AuthMiddleware\(handler http.Handler, permissionFlags AuthFlag\) http.HandlerFunc](<#AuthMiddleware>)
- [func DeleteAuthCookie\(w http.ResponseWriter\)](<#DeleteAuthCookie>)
- [func GenerateSalt\(\) \[\]byte](<#GenerateSalt>)
- [func GetAuthCookie\(r \*http.Request\) \(string, error\)](<#GetAuthCookie>)
- [func NewPSH\(password string, salt \[\]byte\) \[\]byte](<#NewPSH>)
- [func SetAuthCookie\(w http.ResponseWriter, jwt string\)](<#SetAuthCookie>)
- [func ValidatePSH\(password string, salt, psh \[\]byte\) bool](<#ValidatePSH>)
- [type AuthFlag](<#AuthFlag>)
- [type KeyChain](<#KeyChain>)
- [type Session](<#Session>)
  - [func GetSession\(r \*http.Request\) \(Session, bool\)](<#GetSession>)
  - [func NewSession\(username string\) Session](<#NewSession>)
  - [func ValidateJWT\(token string\) \(Session, bool, error\)](<#ValidateJWT>)
  - [func \(ses Session\) Expired\(\) bool](<#Session.Expired>)
  - [func \(ses Session\) NewJWT\(\) \(string, error\)](<#Session.NewJWT>)
  - [func \(ses \*Session\) Refresh\(\)](<#Session.Refresh>)


## Constants

<a name="EncryptionKeysSwitchingTime"></a>

```go
const (
    // Time of a keys switch.
    EncryptionKeysSwitchingTime time.Duration = 60 * time.Minute

    // Size of a signle key in bytes.
    EncryptionKeysSize int = 64
)
```

<a name="PSH_TIME"></a>Argon2 encryption specific parameters

```go
const (
    PSH_TIME = 1
    PSH_MEM  = 64 * 1024
    PSH_THR  = 4
    PSH_LEN  = 64
)
```

<a name="AuthCookieName"></a>Name of authefication cookie.

```go
const AuthCookieName string = "auth"
```

<a name="AuthExpires"></a>After how much time user will be unauthorized. Used in both cookies and expiration time in sessions.

```go
const AuthExpires time.Duration = 60 * time.Minute
```

<a name="JWTheader"></a>JWT header consisting of type itself and algorithm used. Currently [crypto/hmac](<https://pkg.go.dev/crypto/hmac/>) combined with [crypto.SHA512](<https://pkg.go.dev/crypto/#SHA512>) are being used.

```go
const JWTheader = `
{
  "alg": "HS512",
  "typ": "JWT"
}`
```

<a name="SaltSize"></a>Size of a salt that is generated by [GenerateSalt](<#GenerateSalt>) in bytes.

```go
const SaltSize int = 64
```

<a name="AuthMiddleware"></a>
## func AuthMiddleware

```go
func AuthMiddleware(handler http.Handler, permissionFlags AuthFlag) http.HandlerFunc
```

Serves as middleware for handlers and users based on authrization permission flags \(see [AuthFlag](<#AuthFlag>)\). Will block traffic for unintended users and always update valid auth cookies. Logs actions in [log/slog](<https://pkg.go.dev/log/slog/>) logger like blocked users or unexpected permissionFlag.

Save authefication status and whole session data in the [net/http.Request.Context](<https://pkg.go.dev/net/http/#Request.Context>).

<a name="DeleteAuthCookie"></a>
## func DeleteAuthCookie

```go
func DeleteAuthCookie(w http.ResponseWriter)
```

Sets [AuthCookieName](<#AuthCookieName>) cookie max age to \-1 thus deleting it from the user.

<a name="GenerateSalt"></a>
## func GenerateSalt

```go
func GenerateSalt() []byte
```

Returns completly crypto random salt to use for password hashing.

<a name="GetAuthCookie"></a>
## func GetAuthCookie

```go
func GetAuthCookie(r *http.Request) (string, error)
```

Read [AuthCookieName](<#AuthCookieName>) cookie from the request returning its value. Expected value is jwt. Returns error in case of 0 or \>1 cookies were given.

<a name="NewPSH"></a>
## func NewPSH

```go
func NewPSH(password string, salt []byte) []byte
```

PSH \- Password Salted and Hashed. Function simplifies getting hashed password with given salt.

<a name="SetAuthCookie"></a>
## func SetAuthCookie

```go
func SetAuthCookie(w http.ResponseWriter, jwt string)
```

Sets [AuthCookieName](<#AuthCookieName>) cookie with given jwt value. Expects valid jwt. Max age is set to [AuthExpires](<#AuthExpires>) thus having the same value as default session expiration value.

<a name="ValidatePSH"></a>
## func ValidatePSH

```go
func ValidatePSH(password string, salt, psh []byte) bool
```

PSH \- Password Salted and Hashed. Function simplifies validating that given PSH is for the given password and salt combination.

<a name="AuthFlag"></a>
## type AuthFlag

Determine which users are allowed to go through [AuthMiddleware](<#AuthMiddleware>) to see given handler.

```go
type AuthFlag int
```

<a name="Everyone"></a>

```go
const (
    // Allow all and any user further to given handler.
    Everyone AuthFlag = 1 << iota

    // Block all unauthorized users from handler.
    Authorized

    // Block authorized users, can be used for login handlers while already authorized.
    Unauthorized
)
```

<a name="KeyChain"></a>
## type KeyChain

Contains 2 keys and a mutex, making it multiple goroutines save. Used solely by JWT functions.

Keys pair switch keys every [EncryptionKeysSwitchingTime](<#EncryptionKeysSwitchingTime>) minutes, thus providing additional security.

Keys pair consist of:

- current key, which is used for an encrypting and decrypting,
- previous key, which should be used only for decrypting.

Chain itself and all its methods should be used only inside VOS package.

```go
type KeyChain struct {
    // contains filtered or unexported fields
}
```

<a name="Session"></a>
## type Session

Contains all necessary information for other packages to use. All fields must support [encoding/json](<https://pkg.go.dev/encoding/json/>) marshalling/unmarshalling and be tested on that.

```go
type Session struct {
    Username string    `json:"Username"`
    Expire   time.Time `json:"Expire"`
}
```

<a name="GetSession"></a>
### func GetSession

```go
func GetSession(r *http.Request) (Session, bool)
```

Returns [Session](<#Session>) and true if is valid and user is not autheficated. Will always return false in case [AuthMiddleware](<#AuthMiddleware>) was not performed prior.

<a name="NewSession"></a>
### func NewSession

```go
func NewSession(username string) Session
```

Return new session with valid and refreshed expiration time.

<a name="ValidateJWT"></a>
### func ValidateJWT

```go
func ValidateJWT(token string) (Session, bool, error)
```

Returns if given JWT is valid or not. In case of being valid, parses token and returns it as [Session](<#Session>) struct.

Should never return an error, since:

- [hash.Write](<https://pkg.go.dev/hash/#Write>) never returns an error;
- [encoding/json.Unmarshal](<https://pkg.go.dev/encoding/json/#Unmarshal>) works with valid marshalled [Session](<#Session>) thus should not return an error;
- [encoding/base64.URLEncoding.DecodeString](<https://pkg.go.dev/encoding/base64/#URLEncoding.DecodeString>) works with valid encoded [Session](<#Session>) thus should not return an error.

<a name="Session.Expired"></a>
### func \(Session\) Expired

```go
func (ses Session) Expired() bool
```

Reports whether or not session is expired.

<a name="Session.NewJWT"></a>
### func \(Session\) NewJWT

```go
func (ses Session) NewJWT() (string, error)
```

Encodes session into a new JWT.

Should never return an error, since:

- [hash.Write](<https://pkg.go.dev/hash/#Write>) never returns an error;
- [encoding/json.Marshal](<https://pkg.go.dev/encoding/json/#Marshal>) for [Session](<#Session>) should not return an error.

<a name="Session.Refresh"></a>
### func \(\*Session\) Refresh

```go
func (ses *Session) Refresh()
```

Refresh expiration time of the session.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
