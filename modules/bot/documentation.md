<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# bot

```go
import "github.com/TrueHopolok/VladOS/modules/bot"
```

Contain a telegram bot logic to use on the server.

Basicly: BRAIN of the VladOS.

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func CmdFindClosest\(cmdName string\) \[\]string](<#CmdFindClosest>)
- [func CmdInfoAll\(\) \[\]tu.MessageEntityCollection](<#CmdInfoAll>)
- [func CmdInfoOne\(cmdName string\) \[\]tu.MessageEntityCollection](<#CmdInfoOne>)
- [func CmdStart\(ctx \*th.Context, update telego.Update, cmdName string, argsAmount int\) \(bot \*telego.Bot, chatID telego.ChatID, cmdArgs \[\]string, validArgs bool, invalidMSG error\)](<#CmdStart>)
- [func ConnectAll\(bh \*th.BotHandler\)](<#ConnectAll>)
- [func ConnectCommands\(bh \*th.BotHandler\)](<#ConnectCommands>)
- [func ConnectConversation\(bh \*th.BotHandler\)](<#ConnectConversation>)
- [func ConnectJokes\(bh \*th.BotHandler\)](<#ConnectJokes>)
- [func HandleConversation\(ctx \*th.Context, update telego.Update\) error](<#HandleConversation>)
- [func HandleConvoCancel\(ctx \*th.Context, update telego.Update\) error](<#HandleConvoCancel>)
- [func HandleConvoStatus\(ctx \*th.Context, update telego.Update\) error](<#HandleConvoStatus>)
- [func HandleHelp\(ctx \*th.Context, update telego.Update\) error](<#HandleHelp>)
- [func LoggerMiddleware\(ctx \*th.Context, update telego.Update\) error](<#LoggerMiddleware>)
- [func Start\(botErrorChan chan error\) error](<#Start>)
- [func Stop\(\) error](<#Stop>)
- [type CmdRandStatus](<#CmdRandStatus>)
- [type Command](<#Command>)


## Constants

<a name="RandMaxValue"></a>

```go
const RandMaxValue int = 1_000_000_000
```

## Variables

<a name="CommandsList"></a>Stores all commands in the map using initialized variables \(see [Command](<#Command>) type and its variables\).

Few commands are stored and handled seperatly from the list:

- \[HandleSpelling\] is not a command and executed if given command was not spelled correctly \(also partially executed during help command, see [HandleHelp](<#HandleHelp>)\).
- [HandleHelp](<#HandleHelp>) does not serve any purpose for usage except for guidance, thus stored seperatly \(and it has incompability to be stored in global map\).

```go
var CommandsList map[string]map[string]Command = map[string]map[string]Command{
    "Gambling": {},
    "Others": {
        "start": CommandStart,
        "ghoul": CommandGhoul,
        "rand":  CommandRand,
        "tip":   CommandTip,
    },
}
```

<a name="CmdFindClosest"></a>
## func CmdFindClosest

```go
func CmdFindClosest(cmdName string) []string
```

Given command name, finds closest existing commands by spelling.

<a name="CmdInfoAll"></a>
## func CmdInfoAll

```go
func CmdInfoAll() []tu.MessageEntityCollection
```

Returns a message containing info about all of the commands bot has.

<a name="CmdInfoOne"></a>
## func CmdInfoOne

```go
func CmdInfoOne(cmdName string) []tu.MessageEntityCollection
```

Returns a message containing a full info about a single command.

<a name="CmdStart"></a>
## func CmdStart

```go
func CmdStart(ctx *th.Context, update telego.Update, cmdName string, argsAmount int) (bot *telego.Bot, chatID telego.ChatID, cmdArgs []string, validArgs bool, invalidMSG error)
```

Outputs log with info \[cmdName\] in the [log/slog](<https://pkg.go.dev/log/slog/>). Checks if received \[len\(args\)\] is equal to given \[argsAmount\]. Sends a message if it is false.

<a name="ConnectAll"></a>
## func ConnectAll

```go
func ConnectAll(bh *th.BotHandler)
```

Connects all connectors and middlewares into given [github.com/mymmrac/telego/telegohandler.BotHandler](<https://pkg.go.dev/github.com/mymmrac/telego/telegohandler/#BotHandler>) to serve.

- [LoggerMiddleware](<#LoggerMiddleware>),
- [ConnectConversation](<#ConnectConversation>),
- [ConnectCommands](<#ConnectCommands>).

<a name="ConnectCommands"></a>
## func ConnectCommands

```go
func ConnectCommands(bh *th.BotHandler)
```

Create a group in bot handler that handles all incomming commands. See [CommandsList](<#CommandsList>) for all commands details.

<a name="ConnectConversation"></a>
## func ConnectConversation

```go
func ConnectConversation(bh *th.BotHandler)
```



<a name="ConnectJokes"></a>
## func ConnectJokes

```go
func ConnectJokes(bh *th.BotHandler)
```

TODO Connect a handler that analyze the message and find a joke / pun for the suffix of that message.

<a name="HandleConversation"></a>
## func HandleConversation

```go
func HandleConversation(ctx *th.Context, update telego.Update) error
```



<a name="HandleConvoCancel"></a>
## func HandleConvoCancel

```go
func HandleConvoCancel(ctx *th.Context, update telego.Update) error
```



<a name="HandleConvoStatus"></a>
## func HandleConvoStatus

```go
func HandleConvoStatus(ctx *th.Context, update telego.Update) error
```



<a name="HandleHelp"></a>
## func HandleHelp

```go
func HandleHelp(ctx *th.Context, update telego.Update) error
```



<a name="LoggerMiddleware"></a>
## func LoggerMiddleware

```go
func LoggerMiddleware(ctx *th.Context, update telego.Update) error
```

Provides small bot handler middleware to connect for logs purposes using [log/slog](<https://pkg.go.dev/log/slog/>) package.

<a name="Start"></a>
## func Start

```go
func Start(botErrorChan chan error) error
```

Initialize a bot and starts it with handlers connected via [ConnectAll](<#ConnectAll>). Additionaly clears all DB dynamic tables \(those that requires restarting every launch\).

Will stop execution of a previous bot in case it was working previously.

<a name="Stop"></a>
## func Stop

```go
func Stop() error
```

Stop package's global bot from receiving and handling any updates.

<a name="CmdRandStatus"></a>
## type CmdRandStatus



```go
type CmdRandStatus struct {
    // 0 - start, waiting left one
    // 1 - left is given, waiting right one
    Stage int

    Left int
}
```

<a name="Command"></a>
## type Command

Contains the command's handler and the info text that is displayed on help command.

Name of the command is stored in key of the [CommandsList](<#CommandsList>) map.

```go
type Command struct {
    // Description and a usage of the command.
    InfoFull string

    // Brief description about the command.
    InfoBrief string

    // Command handler that executes on command call.
    Handler th.Handler

    // In case the command is multistep (conversation based) this will handle the conversation.
    // See [ConnectConversation] for more details.
    //
    // Value will be nil if conversation handler is not defined.
    Conversation th.Handler
}
```

<a name="CommandGhoul"></a>

```go
var CommandGhoul Command = Command{
    InfoFull: `
 /ghoul
Starts from 1000, subtracts 7.
Result is outputed in the message. Then the process is repeated till the 0. 
 `,
    InfoBrief: "output 1000-7 loop",
    Handler: func(ctx *th.Context, update telego.Update) error {
        bot, chatID, _, valid, err := CmdStart(ctx, update, "ghoul", 0)
        if !valid {
            return err
        }
        for i := 1000; i > 7; i -= 7 {
            _, err := bot.SendMessage(ctx, tu.MessageWithEntities(chatID, tu.Entityf("%4d-7=%-3d", i, i-7).Blockquote()))
            if err != nil {
                return err
            }
        }
        return nil
    },
    Conversation: nil,
}
```

<a name="CommandRand"></a>

```go
var CommandRand Command = Command{
    InfoFull: fmt.Sprintf(`
 /rand
Generates a random number between given numbers in range from 0 till %d included.
Command will give you a prompt asking what min and max values of the random you want.

 /rand <max_num>
Generates a random number between 0 and given number which value is from 0 till %d included.
Command will immediatly send a response. Expects that max_num is in the allowed range.

 /rand <min_num> <max_num>
Generates a random number between 2 given numbers which values is from 0 till %d included.
Command will immediatly send a response. Expects that min_num <= max_num and they are in the allowed range.
`, RandMaxValue, RandMaxValue, RandMaxValue),
    InfoBrief: "generates random number",
    Handler: func(ctx *th.Context, update telego.Update) error {
        slog.Debug("bot handler", "upd", update.UpdateID, "command", "rand")
        bot := ctx.Bot()
        chatID := update.Message.Chat.ChatID()
        _, _, cmdArgs := tu.ParseCommand(update.Message.Text)
        switch len(cmdArgs) {
        case 0:
            _, err := bot.SendMessage(ctx, tu.Messagef(chatID, "Type what minimum value is allowed.\nAllowed values are between 0 and %d (included).", RandMaxValue))
            if err != nil {
                return fmt.Errorf("send msg: %w", err)
            }
            status := CmdRandStatus{
                Stage: 0,
                Left:  0,
            }
            var buf bytes.Buffer
            enc := gob.NewEncoder(&buf)
            if err := enc.Encode(status); err != nil {
                return fmt.Errorf("gob encoder: %w", err)
            }
            return dbconvo.Busy(update.Message.From.ID, "rand", buf.Bytes())
        case 1:
            right, invalid, err := inputRand(ctx, chatID, cmdArgs[0], 0, false)
            if invalid {
                return err
            }

            r := rand.New(rand.NewSource(time.Now().UnixNano()))
            _, err = bot.SendMessage(ctx, tu.MessageWithEntities(chatID, tu.Entityf("Generated number between 0 and %d is:\n\n", right), tu.Entityf("%d", r.Intn(right+1)).Blockquote()))
            return err
        case 2:
            left, invalid, err := inputRand(ctx, chatID, cmdArgs[0], 0, false)
            if invalid {
                return err
            }

            right, invalid, err := inputRand(ctx, chatID, cmdArgs[1], left, false)
            if invalid {
                return err
            }

            r := rand.New(rand.NewSource(time.Now().UnixNano()))
            _, err = bot.SendMessage(ctx, tu.MessageWithEntities(chatID, tu.Entityf("Generated number between %d and %d is:\n\n", left, right), tu.Entityf("%d", r.Intn(right-left+1)+left).Blockquote()))
            return err
        default:
            _, err := bot.SendMessage(ctx, tu.Message(chatID, "Too many arguments are given for the command.\nFor more info type:\n /help rand\n /help"))
            return err
        }
    },
    Conversation: func(ctx *th.Context, update telego.Update) error {
        slog.Debug("bot handler", "upd", update.UpdateID, "command", "rand")
        bot := ctx.Bot()
        chatID := update.Message.Chat.ChatID()
        cs := ctx.Value("ConvoStatus").(dbconvo.Status)
        getbuf := bytes.NewBuffer(cs.Data)
        dec := gob.NewDecoder(getbuf)
        var status CmdRandStatus
        if err := dec.Decode(&status); err != nil {
            return fmt.Errorf("gob decoder: %w", err)
        }
        switch status.Stage {
        case 0:
            left, invalid, err := inputRand(ctx, chatID, update.Message.Text, 0, true)
            if invalid {
                return err
            }

            _, err = bot.SendMessage(ctx, tu.Messagef(chatID, "Type what maximum value is allowed.\nAllowed values are between %d and %d (included).", left, RandMaxValue))
            if err != nil {
                return fmt.Errorf("send msg: %w", err)
            }

            status.Left = left
            status.Stage++
            var buf bytes.Buffer
            enc := gob.NewEncoder(&buf)
            if err := enc.Encode(status); err != nil {
                return fmt.Errorf("gob encoder: %w", err)
            }
            return dbconvo.Busy(update.Message.From.ID, "rand", buf.Bytes())
        case 1:
            right, invalid, err := inputRand(ctx, chatID, update.Message.Text, status.Left, true)
            if invalid {
                return err
            }

            if err := outputRand(ctx, chatID, status.Left, right); err != nil {
                return err
            }

            return dbconvo.Free(update.Message.From.ID)
        }
        return nil
    },
}
```

<a name="CommandStart"></a>

```go
var CommandStart Command = Command{
    InfoBrief: "output info about the bot and its links",
    InfoFull: `
 /start
Output information about bot's life purpose and who it is.
Provide useful links to bot's website. 
`,
    Handler: func(ctx *th.Context, update telego.Update) error {
        bot, chatID, _, valid, err := CmdStart(ctx, update, "start", 0)
        if !valid {
            return err
        }
        _, err = bot.SendMessage(ctx, tu.MessageWithEntities(chatID,
            tu.Entity("Hello, "), tu.Entity("user.\n").Bold(),
            tu.Entity("I am bot "), tu.Entity("VladOS.\nVlad Operation System.\n").Bold(),
            tu.Entity(`
I am a project that combines:
- Gambling telegram bot;
- Reincarnaction of the 'AllEgg' bot from Discord;
- Webpage to control and view bot activities.

Bot will react to any message and will try to find a pun for suffix of the message.

Gambling and other functional via commands.
Type /help for more info about them.
`)))
        return err
    },
    Conversation: nil,
}
```

<a name="CommandTip"></a>

```go
var CommandTip Command = Command{
    InfoBrief: "output some advice/tip/quote",
    InfoFull: `
 /tip
Output a random advice, tip or quote.

 /tip <advice_id>
Output a tip with id equal to given one. 
`,
    Handler: func(ctx *th.Context, update telego.Update) error {
        slog.Debug("bot handler", "upd", update.UpdateID, "command", "tip")
        bot := ctx.Bot()
        chatID := update.Message.Chat.ChatID()
        _, _, cmdArgs := tu.ParseCommand(update.Message.Text)
        var msgText []tu.MessageEntityCollection
        switch len(cmdArgs) {
        case 0:
            tip_text, author, tip_id, err := dbtip.Rand()
            if err != nil {
                return err
            }
            msgText = append(msgText, tu.Entityf("TIP #%d\n", tip_id).Bold(), tu.Entity(tip_text).Blockquote(), tu.Entityf("\n-- %s", author))
        case 1:
            tip_id, err := strconv.Atoi(cmdArgs[0])
            if err != nil || tip_id < 0 {
                _, err := bot.SendMessage(ctx, tu.Message(chatID, "Given argument is invalid, please enter the valid non-negative number.\nFor more info type:\n /help tip\n /help"))
                return err
            }
            tip_text, author, found, err := dbtip.Get(tip_id)
            if err != nil {
                return err
            }
            if !found {
                _, err := bot.SendMessage(ctx, tu.Message(chatID, "The advice/tip with given id does not exists."))
                return err
            }
            msgText = append(msgText, tu.Entityf("TIP #%d\n", tip_id).Bold(), tu.Entity(tip_text).Blockquote(), tu.Entityf("\n-- %s", author))
        default:
            _, err := bot.SendMessage(ctx, tu.Message(chatID, "Too many arguments are given for the command.\nFor more info type:\n /help tip\n /help"))
            return err
        }
        _, err := bot.SendMessage(ctx, tu.MessageWithEntities(chatID, msgText...))
        return err
    },
    Conversation: nil,
}
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
