<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# bot

```go
import "github.com/TrueHopolok/VladOS/modules/bot"
```

Contain a telegram bot logic to use on the server.

Basicly: BRAIN of the VladOS.

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func CmdFindClosest\(cmdName string\) \[\]string](<#CmdFindClosest>)
- [func CmdInfoAll\(\) \[\]tu.MessageEntityCollection](<#CmdInfoAll>)
- [func CmdInfoOne\(cmdName string\) \[\]tu.MessageEntityCollection](<#CmdInfoOne>)
- [func CmdStart\(ctx \*th.Context, update telego.Update, cmdName string, argsAmount int\) \(bot \*telego.Bot, chatID telego.ChatID, cmdArgs \[\]string, validArgs bool, invalidMSG error\)](<#CmdStart>)
- [func ConnectAll\(bh \*th.BotHandler\)](<#ConnectAll>)
- [func ConnectCommands\(bh \*th.BotHandler\)](<#ConnectCommands>)
- [func ConnectConversation\(bh \*th.BotHandler\)](<#ConnectConversation>)
- [func ConnectJokes\(bh \*th.BotHandler\)](<#ConnectJokes>)
- [func HandleConversation\(ctx \*th.Context, update telego.Update\) error](<#HandleConversation>)
- [func HandleConvoCancel\(ctx \*th.Context, update telego.Update\) error](<#HandleConvoCancel>)
- [func HandleConvoStatus\(ctx \*th.Context, update telego.Update\) error](<#HandleConvoStatus>)
- [func HandleHelp\(ctx \*th.Context, update telego.Update\) error](<#HandleHelp>)
- [func HandleSpelling\(ctx \*th.Context, update telego.Update\) error](<#HandleSpelling>)
- [func HandleStart\(ctx \*th.Context, update telego.Update\) error](<#HandleStart>)
- [func LoggerMiddleware\(ctx \*th.Context, update telego.Update\) error](<#LoggerMiddleware>)
- [func Start\(botErrorChan chan error\) error](<#Start>)
- [func Stop\(\) error](<#Stop>)
- [type CmdRandStatus](<#CmdRandStatus>)
- [type Command](<#Command>)


## Constants

<a name="RandMaxValue"></a>

```go
const RandMaxValue int = 1_000_000_000
```

## Variables

<a name="CommandsList"></a>Stores all commands in the map using initialized variables \(see [Command](<#Command>) type and its variables\).

Few commands are stored and handled seperatly from the list:

- [HandleSpelling](<#HandleSpelling>) is not a command and executed if given command was not spelled correctly \(also partially executed during help command, see [HandleHelp](<#HandleHelp>)\).
- [HandleHelp](<#HandleHelp>) does not serve any purpose for usage except for guidance, thus stored seperatly.
- [HandleStart](<#HandleStart>) should be used once thus no need to include in the whole command list.

```go
var CommandsList map[string]map[string]Command = map[string]map[string]Command{
    "Gambling": {},
    "Others": {
        "ghoul": CommandGhoul,
        "rand":  CommandRand,
    },
}
```

<a name="CmdFindClosest"></a>
## func CmdFindClosest

```go
func CmdFindClosest(cmdName string) []string
```

Given command name, finds closest existing commands by spelling.

<a name="CmdInfoAll"></a>
## func CmdInfoAll

```go
func CmdInfoAll() []tu.MessageEntityCollection
```

Returns a message containing info about all of the commands bot has.

<a name="CmdInfoOne"></a>
## func CmdInfoOne

```go
func CmdInfoOne(cmdName string) []tu.MessageEntityCollection
```

Returns a message containing a full info about a single command.

<a name="CmdStart"></a>
## func CmdStart

```go
func CmdStart(ctx *th.Context, update telego.Update, cmdName string, argsAmount int) (bot *telego.Bot, chatID telego.ChatID, cmdArgs []string, validArgs bool, invalidMSG error)
```

Outputs log with info \[cmdName\] in the [log/slog](<https://pkg.go.dev/log/slog/>). Checks if received \[len\(args\)\] is equal to given \[argsAmount\]. Sends a message if it is false.

<a name="ConnectAll"></a>
## func ConnectAll

```go
func ConnectAll(bh *th.BotHandler)
```

Connects all connectors and middlewares into given [github.com/mymmrac/telego/telegohandler.BotHandler](<https://pkg.go.dev/github.com/mymmrac/telego/telegohandler/#BotHandler>) to serve.

- [LoggerMiddleware](<#LoggerMiddleware>),
- [ConnectConversation](<#ConnectConversation>),
- [ConnectCommands](<#ConnectCommands>).

<a name="ConnectCommands"></a>
## func ConnectCommands

```go
func ConnectCommands(bh *th.BotHandler)
```

Create a group in bot handler that handles all incomming commands. See [CommandsList](<#CommandsList>) for all commands details.

<a name="ConnectConversation"></a>
## func ConnectConversation

```go
func ConnectConversation(bh *th.BotHandler)
```



<a name="ConnectJokes"></a>
## func ConnectJokes

```go
func ConnectJokes(bh *th.BotHandler)
```

TODO Connect a handler that analyze the message and find a joke / pun for the suffix of that message.

<a name="HandleConversation"></a>
## func HandleConversation

```go
func HandleConversation(ctx *th.Context, update telego.Update) error
```



<a name="HandleConvoCancel"></a>
## func HandleConvoCancel

```go
func HandleConvoCancel(ctx *th.Context, update telego.Update) error
```



<a name="HandleConvoStatus"></a>
## func HandleConvoStatus

```go
func HandleConvoStatus(ctx *th.Context, update telego.Update) error
```



<a name="HandleHelp"></a>
## func HandleHelp

```go
func HandleHelp(ctx *th.Context, update telego.Update) error
```



<a name="HandleSpelling"></a>
## func HandleSpelling

```go
func HandleSpelling(ctx *th.Context, update telego.Update) error
```



<a name="HandleStart"></a>
## func HandleStart

```go
func HandleStart(ctx *th.Context, update telego.Update) error
```



<a name="LoggerMiddleware"></a>
## func LoggerMiddleware

```go
func LoggerMiddleware(ctx *th.Context, update telego.Update) error
```

Provides small bot handler middleware to connect for logs purposes using [log/slog](<https://pkg.go.dev/log/slog/>) package.

<a name="Start"></a>
## func Start

```go
func Start(botErrorChan chan error) error
```

Initialize a bot and starts it with handlers connected via [ConnectAll](<#ConnectAll>). Additionaly clears all DB dynamic tables \(those that requires restarting every launch\).

Will stop execution of a previous bot in case it was working previously.

<a name="Stop"></a>
## func Stop

```go
func Stop() error
```

Stop package's global bot from receiving and handling any updates.

<a name="CmdRandStatus"></a>
## type CmdRandStatus



```go
type CmdRandStatus struct {
    // 0 - start, waiting left one
    // 1 - left is given, waiting right one
    Stage int

    Left int
}
```

<a name="Command"></a>
## type Command

Contains the command's handler and the info text that is displayed on help command.

Name of the command is stored in key of the [CommandsList](<#CommandsList>) map.

```go
type Command struct {
    // Description and a usage of the command.
    InfoFull string

    // Brief description about the command.
    InfoBrief string

    // Command handler that executes on command call.
    Handler th.Handler

    // In case the command is multistep (conversation based) this will handle the conversation.
    // See [ConnectConversation] for more details.
    //
    // Value will be nil if conversation handler is not defined.
    Conversation th.Handler
}
```

<a name="CommandGhoul"></a>

```go
var CommandGhoul Command = Command{
    InfoFull: `
 /ghoul
Starts from 1000, subtracts 7.
Result is outputed in the message. Then the process is repeated till the 0. 
 `,
    InfoBrief: "output 1000-7 loop",
    Handler: func(ctx *th.Context, update telego.Update) error {
        bot, chatID, _, valid, err := CmdStart(ctx, update, "ghoul", 0)
        if !valid {
            return err
        }
        for i := 1000; i > 7; i -= 7 {
            _, err := bot.SendMessage(ctx, tu.MessageWithEntities(chatID, tu.Entityf("%4d-7=%-3d", i, i-7).Blockquote()))
            if err != nil {
                return err
            }
        }
        return nil
    },
    Conversation: nil,
}
```

<a name="CommandRand"></a>

```go
var CommandRand Command = Command{
    InfoFull: fmt.Sprintf(`
 /rand
Generates a random number between 0 and %d including.
Command will give you a prompt asking what min and max values of the random you want.
`, RandMaxValue),
    InfoBrief: "generates random number",
    Handler: func(ctx *th.Context, update telego.Update) error {
        bot, chatID, _, valid, err := CmdStart(ctx, update, "rand", 0)
        if !valid {
            return err
        }
        _, err = bot.SendMessage(ctx, tu.Message(chatID, "Type what minimum value (including) is allowed."))
        if err != nil {
            return fmt.Errorf("send msg: %w", err)
        }
        status := CmdRandStatus{
            Stage: 0,
            Left:  0,
        }
        var buf bytes.Buffer
        enc := gob.NewEncoder(&buf)
        if err := enc.Encode(status); err != nil {
            return fmt.Errorf("gob encoder: %w", err)
        }
        return dbconvo.Busy(update.Message.From.ID, "rand", buf.Bytes())
    },
    Conversation: func(ctx *th.Context, update telego.Update) error {
        slog.Debug("bot handler", "upd", update.UpdateID, "command", "rand")
        bot := ctx.Bot()
        chatID := update.Message.Chat.ChatID()
        cs := ctx.Value("ConvoStatus").(dbconvo.Status)
        getbuf := bytes.NewBuffer(cs.Data)
        dec := gob.NewDecoder(getbuf)
        var status CmdRandStatus
        if err := dec.Decode(&status); err != nil {
            return fmt.Errorf("gob decoder: %w", err)
        }
        switch status.Stage {
        case 0:
            value, err := strconv.Atoi(update.Message.Text)
            if err != nil || value < 0 || value > RandMaxValue {
                _, err = bot.SendMessage(ctx, tu.Messagef(chatID, "Inputed text is invalid number, please enter the valid number between 0 and %d (included).\nTo cancel execution of the command type /cancel.", RandMaxValue))
                if err != nil {
                    return fmt.Errorf("send msg: %w", err)
                }
                return nil
            }

            _, err = bot.SendMessage(ctx, tu.Message(chatID, "Type what maximum value (including) is allowed."))
            if err != nil {
                return fmt.Errorf("send msg: %w", err)
            }

            status.Left = value
            status.Stage++
            var buf bytes.Buffer
            enc := gob.NewEncoder(&buf)
            if err := enc.Encode(status); err != nil {
                return fmt.Errorf("gob encoder: %w", err)
            }
            return dbconvo.Busy(update.Message.From.ID, "rand", buf.Bytes())
        case 1:
            value, err := strconv.Atoi(update.Message.Text)
            if err != nil || value < status.Left || value > RandMaxValue {
                _, err = bot.SendMessage(ctx, tu.Messagef(chatID, "Inputed text is invalid number, please enter the valid number between %d and %d (included).\nTo cancel execution of the command type /cancel.", status.Left, RandMaxValue))
                if err != nil {
                    return fmt.Errorf("send msg: %w", err)
                }
                return nil
            }

            r := rand.New(rand.NewSource(time.Now().UnixNano()))
            _, err = bot.SendMessage(ctx, tu.MessageWithEntities(chatID, tu.Entityf("Generated number between %d and %d is:\n\n", status.Left, value), tu.Entityf("%d", r.Intn(value+1)+status.Left).Blockquote()))
            if err != nil {
                return fmt.Errorf("send msg: %w", err)
            }

            return dbconvo.Free(update.Message.From.ID)
        }
        return nil
    },
}
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
